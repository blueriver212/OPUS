import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# Load lookup file generated by MATLAB
# ------------------------------------------------------------
data = sio.loadmat("disposal_lookup.mat", squeeze_me=True, struct_as_record=False)
lookup = data["lookup"]

# Access MATLAB struct fields safely
years = np.array(lookup.years, dtype=int).flatten()
apogee_alts = np.array(lookup.apogee_alts_km).flatten()
perigee_alts = np.array(lookup.perigee_alts_km).flatten()
coef_logquad = np.array(lookup.coef_logquad)   # shape (ny, na, 3)
R2_log = np.array(lookup.R2_log)

# ------------------------------------------------------------
# Define the inverse quadratic function: log(y) = a*x^2 + b*x + c
# ------------------------------------------------------------
def inv_logquad_for_y(p, y_target, xmin, xmax):
    """Solve for x given coefficients [a,b,c] of log(y)=a*x^2+b*x+c."""
    a, b, c = p
    c -= np.log(y_target)
    D = b**2 - 4*a*c
    if D < 0:
        return np.nan
    roots = np.array([(-b + np.sqrt(D)) / (2*a), (-b - np.sqrt(D)) / (2*a)])
    roots = roots[(roots >= xmin) & (roots <= xmax)]
    if roots.size == 0:
        return np.nan
    return roots[np.argmin(np.abs(roots - 0.5 * (xmin + xmax)))]

# ------------------------------------------------------------
# Example: get perigee altitude for given target lifetime & start year
# ------------------------------------------------------------
target_years = 5.0  # desired disposal lifetime
year_query = 2028   # starting year
iy = np.argmin(np.abs(years - year_query))

perigee_min, perigee_max = perigee_alts.min(), perigee_alts.max()
req_perigee = np.full_like(apogee_alts, np.nan, dtype=float)

for ia, apogee in enumerate(apogee_alts):
    p = coef_logquad[iy, ia, :]
    if np.any(np.isnan(p)):
        continue
    hp = inv_logquad_for_y(p, target_years, perigee_min, perigee_max)
    if np.isnan(hp) or hp > apogee or hp < perigee_min:
        continue
    req_perigee[ia] = hp

# ------------------------------------------------------------
# Plot for that start year
# ------------------------------------------------------------
plt.figure(figsize=(8, 5))
plt.plot(apogee_alts, req_perigee, "o-", lw=1.8)
plt.xlabel("Apogee altitude (km)")
plt.ylabel("Required perigee altitude (km)")
plt.title(f"Required perigee for {target_years:.0f}-year disposal (start {year_query})")
plt.grid(True)
plt.show()
import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt

# ------------------------------------------------------------
# Load lookup file generated by MATLAB
# ------------------------------------------------------------
data = sio.loadmat("disposal_lookup.mat", squeeze_me=True, struct_as_record=False)
lookup = data["lookup"]

# Access MATLAB struct fields safely
years = np.array(lookup.years, dtype=int).flatten()
apogee_alts = np.array(lookup.apogee_alts_km).flatten()
perigee_alts = np.array(lookup.perigee_alts_km).flatten()
coef_logquad = np.array(lookup.coef_logquad)   # shape (ny, na, 3)
R2_log = np.array(lookup.R2_log)

# ------------------------------------------------------------
# Define the inverse quadratic function: log(y) = a*x^2 + b*x + c
# ------------------------------------------------------------
def inv_logquad_for_y(p, y_target, xmin, xmax):
    """Solve for x given coefficients [a,b,c] of log(y)=a*x^2+b*x+c."""
    if p is None or np.any(np.isnan(p)):
        return np.nan
    a, b, c = p
    c = c - np.log(y_target)
    D = b**2 - 4*a*c
    if D < 0:
        return np.nan
    roots = np.array([(-b + np.sqrt(D)) / (2*a), (-b - np.sqrt(D)) / (2*a)])
    roots = roots[(roots >= xmin) & (roots <= xmax)]
    if roots.size == 0:
        return np.nan
    return roots[np.argmin(np.abs(roots - 0.5 * (xmin + xmax)))]

# ------------------------------------------------------------
# Compute required perigee curve for a given start year
# ------------------------------------------------------------
def required_perigee_curve_for_year(iy, target_years):
    """Return required perigee (km) vs apogee (km) for years[iy]."""
    perigee_min, perigee_max = float(perigee_alts.min()), float(perigee_alts.max())
    req_perigee = np.full_like(apogee_alts, np.nan, dtype=float)
    for ia, apogee in enumerate(apogee_alts):
        p = coef_logquad[iy, ia, :]
        if np.any(np.isnan(p)):
            continue
        hp = inv_logquad_for_y(p, target_years, perigee_min, perigee_max)
        # Skip invalid/physically impossible solutions
        if np.isnan(hp) or (hp > apogee) or (hp < perigee_min) or (hp > perigee_max):
            continue
        # Optional: reject low-quality fits
        if R2_log.size and not np.isnan(R2_log[iy, ia]) and R2_log[iy, ia] < 0.95:
            continue
        req_perigee[ia] = hp
    return req_perigee

# ------------------------------------------------------------
# Plot for ALL available start years
# ------------------------------------------------------------
target_years = 5.0  # desired disposal lifetime in years

plt.figure(figsize=(10, 6))
colors = plt.cm.viridis(np.linspace(0.05, 0.95, len(years)))
handles = []
labels = []

for iy, year in enumerate(years):
    curve = required_perigee_curve_for_year(iy, target_years)
    if np.all(np.isnan(curve)):
        continue  # nothing to plot for this year
    h, = plt.plot(apogee_alts, curve, "o-", lw=1.8, ms=4, color=colors[iy])
    handles.append(h)
    labels.append(f"{year}")

plt.xlabel("Apogee altitude (km)")
plt.ylabel("Required perigee altitude (km)")
plt.title(f"Required perigee for {target_years:.0f}-year disposal â€” all available years")
plt.grid(True, alpha=0.35)
if handles:
    plt.legend(handles, labels, title="Start year", fontsize=9, ncol=2)
plt.tight_layout()
plt.show()

# ------------------------------------------------------------
# (Optional) Save to file
# ------------------------------------------------------------
# plt.savefig("required_perigee_all_years.png", dpi=150)